{"version":3,"file":"authClientConnection.js","sourceRoot":"","sources":["../../src/authClientConnection.ts"],"names":[],"mappings":"AACA,OAAO,EAAsB,iBAAiB,EAAE,MAAM,wBAAwB,CAAC;AAE/E,OAAO,EAAE,wBAAwB,EAAE,MAAM,0BAA0B,CAAC;AAkBpE,MAAM,OAAO,oBAAoB;IAC/B,QAAQ,CAAwC;IAChD,oBAAoB,GAAG,IAAI,GAAG,EAAc,CAAC;IAC7C,0BAA0B,CAAkC;IAE5D,YAAY,OAAoC;QAC9C,IAAI,CAAC,QAAQ,GAAG;YACd,sBAAsB,EAAE,EAAE;YAC1B,sCAAsC,EAAE,IAAI;YAC5C,GAAG,OAAO;SACX,CAAC;QACF,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;YACnB,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC5B,CAAC;IACH,CAAC;IAED,IAAI,SAAS;QACX,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,WAAW,EAAE,CAAC;QACxD,IAAI,QAAQ,CAAC,YAAY,EAAE,CAAC,WAAW,EAAE,EAAE,CAAC;YAC1C,OAAO,KAAK,CAAC;QACf,CAAC;QACD,MAAM,kBAAkB,GAAG,QAA8B,CAAC;QAC1D,OAAO,iBAAiB,CAAC,kBAAkB,CAAC,aAAa,EAAE,CAAC,CAAC;IAC/D,CAAC;IAED,KAAK,CAAC,OAAO;QACX,OAAO,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YAC3C,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC;gBAC7B,GAAG,IAAI,CAAC,QAAQ,CAAC,sBAAsB;gBACvC,SAAS,EAAE,GAAG,EAAE;oBACd,IAAI,CAAC,kBAAkB,EAAE,CAAC;oBAC1B,OAAO,EAAE,CAAC;gBACZ,CAAC;gBACD,OAAO,EAAE,CAAC,KAAK,EAAE,EAAE,CACjB,MAAM,CACJ,IAAI,wBAAwB,CAAC,KAAK,IAAI,yBAAyB,CAAC,CACjE;aACJ,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAED,KAAK,CAAC,UAAU;QACd,aAAa,CAAC,IAAI,CAAC,0BAA0B,CAAC,CAAC;QAC/C,MAAM,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC;QACxC,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,QAAQ,EAAE,CAAC,CAAC;IAC9D,CAAC;IAED,gBAAgB,CAAC,KAAmB,EAAE,QAAoB;QACxD,QAAQ,KAAK,EAAE,CAAC;YACd,KAAK,YAAY;gBACf,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;gBACxC,OAAO,GAAG,EAAE;oBACV,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;gBAC7C,CAAC,CAAC;QACN,CAAC;IACH,CAAC;IAED,kBAAkB;QAChB,IAAI,CAAC,0BAA0B,GAAG,WAAW,CAAC,GAAG,EAAE;YACjD,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;gBACpB,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,QAAQ,EAAE,CAAC,CAAC;gBAC5D,aAAa,CAAC,IAAI,CAAC,0BAA0B,CAAC,CAAC;YACjD,CAAC;QACH,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,sCAAsC,CAAC,CAAC;IAC3D,CAAC;CACF","sourcesContent":["import type { AuthClient, AuthClientLoginOptions } from \"@icp-sdk/auth/client\";\nimport { DelegationIdentity, isDelegationValid } from \"@icp-sdk/core/identity\";\nimport type { Connection } from \"@slide-computer/signer\";\nimport { AuthClientTransportError } from \"./authClientTransport.js\";\n\ninterface AuthClientConnectionOptions {\n  /**\n   * AuthClient instance from \"@icp-sdk/core/auth-client\"\n   */\n  authClient: AuthClient;\n  /**\n   * Login options used to log in with AuthClient instance\n   */\n  authClientLoginOptions?: AuthClientLoginOptions;\n  /**\n   * Auth Client disconnect monitoring interval in ms\n   * @default 3000\n   */\n  authClientDisconnectMonitoringInterval?: number;\n}\n\nexport class AuthClientConnection implements Connection {\n  #options: Required<AuthClientConnectionOptions>;\n  #disconnectListeners = new Set<() => void>();\n  #disconnectMonitorInterval?: ReturnType<typeof setInterval>;\n\n  constructor(options: AuthClientConnectionOptions) {\n    this.#options = {\n      authClientLoginOptions: {},\n      authClientDisconnectMonitoringInterval: 3000,\n      ...options,\n    };\n    if (this.connected) {\n      this.#monitorDisconnect();\n    }\n  }\n\n  get connected() {\n    const identity = this.#options.authClient.getIdentity();\n    if (identity.getPrincipal().isAnonymous()) {\n      return false;\n    }\n    const delegationIdentity = identity as DelegationIdentity;\n    return isDelegationValid(delegationIdentity.getDelegation());\n  }\n\n  async connect(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this.#options.authClient.login({\n        ...this.#options.authClientLoginOptions,\n        onSuccess: () => {\n          this.#monitorDisconnect();\n          resolve();\n        },\n        onError: (error) =>\n          reject(\n            new AuthClientTransportError(error ?? \"AuthClient login failed\"),\n          ),\n      });\n    });\n  }\n\n  async disconnect(): Promise<void> {\n    clearInterval(this.#disconnectMonitorInterval);\n    await this.#options.authClient.logout();\n    this.#disconnectListeners.forEach((listener) => listener());\n  }\n\n  addEventListener(event: \"disconnect\", listener: () => void): () => void {\n    switch (event) {\n      case \"disconnect\":\n        this.#disconnectListeners.add(listener);\n        return () => {\n          this.#disconnectListeners.delete(listener);\n        };\n    }\n  }\n\n  #monitorDisconnect() {\n    this.#disconnectMonitorInterval = setInterval(() => {\n      if (!this.connected) {\n        this.#disconnectListeners.forEach((listener) => listener());\n        clearInterval(this.#disconnectMonitorInterval);\n      }\n    }, this.#options.authClientDisconnectMonitoringInterval);\n  }\n}\n"]}