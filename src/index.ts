import {
  Agent,
  ApiQueryResponse,
  CallOptions,
  Certificate,
  concat,
  CreateCertificateOptions,
  Expiry,
  HttpAgent,
  Identity,
  PublicKey,
  QueryFields,
  QueryResponseStatus,
  ReadStateOptions,
  ReadStateResponse,
  requestIdOf,
  RequestStatusResponseStatus,
  Signature,
  SignIdentity,
  SubmitRequestType,
  SubmitResponse,
} from "@dfinity/agent";
import { JsonObject } from "@dfinity/candid";
import {
  CanisterCallJsonRequest,
  CanisterCallJsonResponse,
  PermissionJsonRequest,
  PermissionJsonResponse,
  Transport,
} from "./types";
import { Buffer } from "buffer";
import { Principal } from "@dfinity/principal";
import {
  Delegation,
  DelegationChain,
  DelegationIdentity,
  isDelegationValid,
} from "@dfinity/identity";
import { isIdentitySignatureValid } from "./identity";

export const ICP_NETWORK_CHAIN_ID = "icp:737ba355e855bd4b61279056603e0550";
export const ICP_NETWORK_NAME = "Internet Computer";
// Default delta for ingress expiry is 5 minutes
const DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1000;

interface WalletAgentOptions {
  transport: Transport;
  crypto?: Pick<Crypto, "randomUUID" | "getRandomValues">;
  /**
   * Optional, used to fetch root key and make calls with delegation chain,
   * HttpAgent with default options will be used when not set
   */
  agent?: HttpAgent;
  /** Optional polyfill for BLS verify used in query requests that are upgraded to calls */
  blsVerify?: CreateCertificateOptions["blsVerify"];
  /**
   * Optional, canister_call RPC calls can also be made with a signed challenge to skip the origin check,
   * also when "delegation" scope and public key are set in the permission request a delegation chain
   * is returned for the public key of this identity
   */
  identity?: Pick<SignIdentity, "getPublicKey" | "sign">;
}

export interface PermissionRequestParams {
  version: 1;
  appMetaData: {
    name: string;
    icon?: string;
  };
  /** Optional, will be generated by WalletAgent when not defined */
  networks?: Array<{
    chainId: string;
    name?: string;
  }>;
  scopes: Array<"canister_call" | "delegation">;
  /** Optional, will be generated by WalletAgent when not defined */
  challenge?: ArrayBuffer;
  targets?: Principal[];
}

export interface PermissionResponseResult {
  version: 1;
  appMetaData: {
    name: string;
    icon?: string;
  };
  scopes: Array<"canister_call" | "delegation">;
  identities: Array<{
    publicKey: PublicKey;
    signature: Signature;
    ledger?: {
      subaccounts?: Array<{
        bytes: ArrayBuffer;
        name?: string;
      }>;
    };
    /**
     * Will be returned if above challenge signature was signed with a delegated public key or
     * when "delegation" scope and public key are set in the permission request
     */
    delegationChain?: DelegationChain;
  }>;
}

export class WalletAgent implements Agent {
  /** Required, sender must be set to make calls */
  public sender?: Principal;
  /** Optional, if delegation is valid for the call, the call will be made with delegation instead of JSON-RPC */
  public delegationChain?: DelegationChain;

  private agent: HttpAgent;
  private readStateResponses: Record<string, Promise<ReadStateResponse>> = {};
  private delegatedRequests: string[] = [];

  constructor(private options: WalletAgentOptions) {
    this.agent = options.agent ?? new HttpAgent();
  }

  public get rootKey() {
    return this.agent.rootKey;
  }

  public async permission(
    params: PermissionRequestParams,
  ): Promise<PermissionResponseResult> {
    return new Promise<PermissionResponseResult>(async (resolve, reject) => {
      const id = this.getCrypto().randomUUID();
      const challenge = params.challenge
        ? new Uint8Array(params.challenge)
        : this.getCrypto().getRandomValues(new Uint8Array(32));
      const listener =
        await this.options.transport.registerListener<PermissionJsonResponse>(
          async (response) => {
            if (response.id !== id) {
              return;
            }
            if ("error" in response) {
              reject(response.error);
              listener();
              return;
            }
            if ("result" in response) {
              const result: PermissionResponseResult = {
                version: response.result.version,
                appMetaData: {
                  name: response.result.appMetaData.name,
                  icon: response.result.appMetaData.icon,
                },
                scopes: response.result.scopes,
                identities: response.result.identities.map((identity) => {
                  const derEncodedPublicKey = Buffer.from(
                    identity.publicKey,
                    "base64",
                  );
                  return {
                    publicKey: { toDer: () => derEncodedPublicKey },
                    signature: Buffer.from(identity.signature, "base64").buffer as Signature,
                    delegationChain: identity.delegationChain
                      ? DelegationChain.fromDelegations(
                          identity.delegationChain.map((item) => ({
                            delegation: new Delegation(
                              Buffer.from(item.delegation.publicKey, "base64"),
                              BigInt(item.delegation.expiration),
                              item.delegation.targets?.map((target) =>
                                Principal.fromText(target),
                              ),
                            ),
                            signature: Buffer.from(item.signature, "base64").buffer as Signature,
                          })),
                          derEncodedPublicKey,
                        )
                      : undefined,
                    ledger: identity.ledger
                      ? {
                          subaccounts: identity.ledger.subaccounts?.map(
                            (subaccount) => ({
                              bytes: Buffer.from(subaccount.bytes, "base64"),
                              name: subaccount.name,
                            }),
                          ),
                        }
                      : undefined,
                  };
                }),
              };
              const walletChallenge = new Uint8Array(
                concat(
                  new TextEncoder().encode("\x0Aic-wallet-challenge").buffer,
                  challenge,
                ),
              );
              // Signature validation is done one by one, so we don't have to wait for remaining identity validations
              // after an identity is found to be invalid. Since the validation is not native but runs in the JS thread,
              // running them in parallel does not make a difference in performance since JS is single threaded.
              for (const identity of result.identities) {
                if (
                  !(await isIdentitySignatureValid(
                    identity.publicKey,
                    walletChallenge,
                    walletChallenge,
                    identity.delegationChain,
                  ))
                ) {
                  reject("Identity signature is invalid");
                  listener();
                  return;
                }
              }
              resolve(result);
              listener();
              return;
            }
          },
        );
      await this.options.transport.send<PermissionJsonRequest>({
        id,
        jsonrpc: "2.0",
        method: "permission",
        params: {
          version: params.version,
          appMetaData: params.appMetaData,
          networks: params.networks ?? [
            {
              chainId: ICP_NETWORK_CHAIN_ID,
              name: ICP_NETWORK_NAME,
            },
          ],
          scopes: params.scopes,
          challenge: Buffer.from(challenge).toString("base64"),
          publicKey: this.options.identity
            ? Buffer.from(
                this.options.identity.getPublicKey().toDer(),
              ).toString("base64")
            : undefined,
          targets: params.targets
            ? params.targets.map((target) => target.toText())
            : undefined,
        },
      });
    });
  }

  public async call(
    canisterId: Principal | string,
    fields: CallOptions,
  ): Promise<SubmitResponse> {
    if (
      this.delegationChain &&
      this.options.identity &&
      isDelegationValid(this.delegationChain, { scope: canisterId })
    ) {
      const submitResponse = await this.agent.call(
        canisterId,
        fields,
        DelegationIdentity.fromDelegation(
          this.options.identity,
          this.delegationChain,
        ),
      );
      this.delegatedRequests.push(
        Buffer.from(submitResponse.requestId).toString("base64"),
      );
      return submitResponse;
    }
    if (!this.sender) {
      throw Error(
        "Sender is not defined, make sure to set sender after permission request",
      );
    }
    const requestId = requestIdOf({
      request_type: SubmitRequestType.Call,
      canister_id: Principal.from(canisterId),
      method_name: fields.methodName,
      arg: fields.arg,
      sender: this.sender,
      ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),
    });
    const id = Buffer.from(requestId).toString("base64");
    let resolveReadStateResponse: (value: ReadStateResponse) => void;
    let rejectReadStateResponse: (reason?: any) => void;
    this.readStateResponses[id] = new Promise<ReadStateResponse>(
      (resolve, reject) => {
        resolveReadStateResponse = resolve;
        rejectReadStateResponse = reject;
      },
    );
    const listener =
      await this.options.transport.registerListener<CanisterCallJsonResponse>(
        async (response) => {
          if (response.id !== id) {
            return;
          }
          if ("error" in response) {
            rejectReadStateResponse(response.error);
            listener();
            return;
          }
          if ("result" in response) {
            resolveReadStateResponse({
              certificate: Buffer.from(response.result.certificate).buffer,
            });
            listener();
          }
        },
      );
    await this.options.transport.send<CanisterCallJsonRequest>({
      id,
      jsonrpc: "2.0",
      method: "canister_call",
      params: {
        version: 1,
        network: {
          chainId: ICP_NETWORK_CHAIN_ID,
          name: ICP_NETWORK_NAME,
        },
        canisterId: Principal.from(canisterId).toText(),
        sender: this.sender!.toText(),
        method: fields.methodName,
        arg: Buffer.from(fields.arg).toString("base64"),
        publicKey: this.options.identity
          ? Buffer.from(this.options.identity.getPublicKey().toDer()).toString(
              "base64",
            )
          : undefined,
        challenge: this.options.identity
          ? Buffer.from(await this.options.identity.sign(requestId)).toString(
              "base64",
            )
          : undefined,
      },
    });
    return {
      requestId,
      response: {
        ok: true,
        status: 200,
        statusText: "Call has been sent over JSON-RPC",
        body: null,
        headers: [],
      },
    };
  }

  public async fetchRootKey(): Promise<ArrayBuffer> {
    return this.agent.fetchRootKey();
  }

  public async getPrincipal(): Promise<Principal> {
    return this.sender ?? Principal.anonymous();
  }

  public async query(
    canisterId: Principal | string,
    options: QueryFields,
  ): Promise<ApiQueryResponse> {
    if (
      this.delegationChain &&
      this.options.identity &&
      isDelegationValid(this.delegationChain, { scope: canisterId })
    ) {
      return this.agent.query(
        canisterId,
        options,
        DelegationIdentity.fromDelegation(
          this.options.identity,
          this.delegationChain,
        ),
      );
    }
    // Upgrade query request to a call
    const submitResponse = await this.call(canisterId, {
      ...options,
      effectiveCanisterId: canisterId,
    });
    const state =
      await this.readStateResponses[
        Buffer.from(submitResponse.requestId).toString("base64")
      ];
    if (this.rootKey == null) {
      throw new Error("Agent root key not initialized");
    }
    const cert = await Certificate.create({
      certificate: state.certificate,
      rootKey: this.rootKey,
      canisterId: Principal.from(canisterId),
      blsVerify: this.options.blsVerify,
    });
    const path = [
      new TextEncoder().encode("request_status"),
      submitResponse.requestId,
    ];
    const maybeBuf = cert.lookup([...path, new TextEncoder().encode("status")]);
    const status = maybeBuf && new TextDecoder().decode(maybeBuf);
    if (status === RequestStatusResponseStatus.Replied) {
      return {
        status: QueryResponseStatus.Replied,
        reply: {
          arg: cert.lookup([...path, "reply"])!,
        },
        httpDetails: {
          ok: true,
          status: 200,
          statusText: "Certificate with reply has been received over JSON-RPC",
          headers: [],
        },
      };
    }
    throw Error("Certificate is missing reply");
  }

  public async createReadStateRequest(
    fields: ReadStateOptions,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ): Promise<any> {
    const id = this.requestIdFromReadStateOptions(fields);
    if (
      id &&
      this.delegatedRequests.includes(id) &&
      this.delegationChain &&
      this.options.identity
    ) {
      return this.agent.createReadStateRequest(
        fields,
        DelegationIdentity.fromDelegation(
          this.options.identity,
          this.delegationChain,
        ),
      );
    }
  }

  public async readState(
    effectiveCanisterId: Principal | string,
    fields: ReadStateOptions,
    identity?: Identity | Promise<Identity>,
    // eslint-disable-next-line
    request?: any,
  ): Promise<ReadStateResponse> {
    const id = this.requestIdFromReadStateOptions(fields);
    if (
      id &&
      this.delegatedRequests.includes(id) &&
      this.delegationChain &&
      this.options.identity
    ) {
      return this.agent.readState(
        effectiveCanisterId,
        fields,
        DelegationIdentity.fromDelegation(
          this.options.identity,
          this.delegationChain,
        ),
        request,
      );
    }
    if (id && id in this.readStateResponses) {
      const readStateResponse = this.readStateResponses[id];
      delete this.readStateResponses[id];
      return readStateResponse;
    }
    throw Error(
      "Invalid read state request, request wasn't made through the WalletAgent",
    );
  }

  public async status(): Promise<JsonObject> {
    return this.agent.status();
  }

  private requestIdFromReadStateOptions = (
    options: ReadStateOptions,
  ): string | undefined => {
    if (options.paths.length === 1 && options.paths[0].length == 2) {
      const path = new TextDecoder().decode(options.paths[0][0]);
      if (path === "request_status") {
        return Buffer.from(options.paths[0][1]).toString("base64");
      }
    }
  };

  private getCrypto(): Pick<Crypto, "randomUUID" | "getRandomValues"> {
    return this.options.crypto ?? window.crypto;
  }
}

export * from "./transport";
export * from "./challenge";
export * from "./types";
